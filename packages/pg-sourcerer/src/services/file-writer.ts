/**
 * File Writer Service
 *
 * Writes buffered emissions to disk using @effect/platform FileSystem.
 */
import { Context, Effect, Layer, pipe, Array as Arr } from "effect"
import { FileSystem, Path } from "@effect/platform"
import type { PlatformError } from "@effect/platform/Error"
import type { EmissionEntry } from "./emissions.js"
import { WriteError } from "../errors.js"

/**
 * Result of a write operation
 */
export interface WriteResult {
  readonly path: string
  readonly written: boolean
  readonly reason?: string
}

/**
 * Options for writing files
 */
export interface WriteOptions {
  /** Output directory root */
  readonly outputDir: string
  /** Dry run mode - don't actually write, just return what would be written */
  readonly dryRun?: boolean
  /** Header to prepend to generated files */
  readonly header?: string
}

/**
 * File writer interface
 */
export interface FileWriter {
  /**
   * Write all emissions to disk
   */
  readonly writeAll: (
    emissions: readonly EmissionEntry[],
    options: WriteOptions
  ) => Effect.Effect<readonly WriteResult[], WriteError, FileSystem.FileSystem | Path.Path>
}

/**
 * FileWriter service tag
 */
export class FileWriterSvc extends Context.Tag("FileWriter")<
  FileWriterSvc,
  FileWriter
>() {}

/**
 * Default generated file header
 */
export const defaultHeader = (timestamp: Date = new Date()): string =>
  `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by pg-sourcerer at ${timestamp.toISOString()}
 */

`

/**
 * Map a PlatformError to a WriteError
 */
const toWriteError = (path: string) => (err: PlatformError): WriteError =>
  new WriteError({
    message: `File operation failed: ${path} - ${err.message}`,
    path,
    cause: err,
  })

/**
 * Create a file writer
 */
export function createFileWriter(): FileWriter {
  return {
    writeAll: (emissions, options) =>
      Effect.gen(function* () {
        const fs = yield* FileSystem.FileSystem
        const pathSvc = yield* Path.Path

        const header = options.header ?? defaultHeader()
        const outputDir = options.outputDir

        // Collect unique directories that need to be created
        const directories = pipe(
          emissions,
          Arr.map((e) => pathSvc.dirname(pathSvc.join(outputDir, e.path))),
          Arr.dedupe
        )

        // In dry-run mode, just return what would be written
        if (options.dryRun) {
          return pipe(
            emissions,
            Arr.map((e): WriteResult => ({
              path: pathSvc.join(outputDir, e.path),
              written: false,
              reason: "dry-run",
            }))
          )
        }

        // Create directories
        yield* Effect.forEach(
          directories,
          (dir) =>
            fs.makeDirectory(dir, { recursive: true }).pipe(
              Effect.catchAll((err) =>
                // Ignore "already exists" errors
                err._tag === "SystemError" && err.reason === "AlreadyExists"
                  ? Effect.void
                  : Effect.fail(toWriteError(dir)(err))
              )
            ),
          { concurrency: 1 } // Sequential to avoid race conditions
        )

        // Write files
        const results = yield* Effect.forEach(
          emissions,
          (entry): Effect.Effect<WriteResult, WriteError> => {
            const fullPath = pathSvc.join(outputDir, entry.path)
            const contentWithHeader = header + entry.content

            return fs.writeFileString(fullPath, contentWithHeader).pipe(
              Effect.map((): WriteResult => ({
                path: fullPath,
                written: true,
              })),
              Effect.catchAll((err) => Effect.fail(toWriteError(fullPath)(err)))
            )
          },
          { concurrency: 10 } // Parallel file writes
        )

        return results
      }),
  }
}

/**
 * Live layer - provides the file writer with real filesystem operations
 */
export const FileWriterLive = Layer.succeed(FileWriterSvc, createFileWriter())
